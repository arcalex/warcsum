#! /usr/bin/perl

# Copyright (C) 2015 Bibliotheca Alexandrina

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# warcsumsplit takes a large hash manifest file and number of partitions
# as input, and attempts to split the large hash manifest file into
# number of smaller hash manifest files equal to or less than the input
# number of parititons.
#
# warcsumsplit will never break a sequence of hash manifests with the
# same hash, which might produce uneven parition.

# Input 
#
# Large hash manifest sorted on the hash with the following format:
# <WARC filename> <member offset> <member end> <URI> <date> <hash digest>

# Output 
#
# Smaller hash manifest files sorted on the hash with the following
# format:
#
# <WARC filename> <member offset> <member end> <URI> <date> <hash digest>

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper qw(Dumper);

my $input_filename = "";
my $partition_count = 0;
my $verbose;

################################
# Parse the program's options. #
################################

GetOptions ("input=s" => \$input_filename, # input filename
    "count=i" => \$partition_count, # number of required partitions
    "verbose" => \$verbose) # verbose mode
  or die("Usage: warcsumsplit.pl [-i | --input <input_file>] ",
    "[-c | --count <number_of_partitions>] [-v | --verbose]");


unless(-e $input_filename)
{
  die "Error: input file $input_filename does not exist.";
}

unless(-r $input_filename)
{
  die "Error: input file $input_filename is not readable.";
}

unless($partition_count =~ /^[+]?\d+\z/ and $partition_count != 0)
{
  die "Error: $partition_count is an invalid number of split counts.";
}

my $input_size = -s $input_filename
  or die "Error: input file $input_filename is empty.";

print "File size is: $input_size";

########################################################
# Calculate the approximate indices for the partitions #
########################################################

my @partition_index;

$partition_index[0] = 0;

for my $i (1 .. $partition_count)
{
  use integer;
  $partition_index[$i] = $input_size / $partition_count * $i;
}

print Dumper \@partition_index;

open(my $input, "<", $input_filename)
  or die "Error: cannot open $input_filename for reading: $!";

my @real_partition_index;

$real_partition_index[0] = 0;

seek($input, $partition_index[1], 0);

my $line = <$input>;

print $line;

defined($line = <$input>)
  or warn "Error: Could not read line at $.: $!";

my $hash = (split(' ', $line))[-1];

print $hash;

my $hash2 = $hash;

my $line2 = "";

my $current_pos = tell($input);

$real_partition_index[1] = $current_pos;

while($hash eq $hash2 and defined($line2 = <$input>))
{
  $real_partition_index[1] = $current_pos;
  $current_pos = tell($input);
  print $line2;
  $hash2 = (split(' ', $line2))[-1];
}

$real_partition_index[$#real_partition_index + 1] = $input_size;

seek($input, 0, 0);

open(my $output, ">", "$input_filename.1")
  or die "Error: cannot open $input_filename for reading: $!";

my $read;

while(defined($read = <$input>) and $real_partition_index[1] > tell($output))
{
  print $output $read;
}

close($output)
 or warn "Error: Unable to close the input file $input_filename.1: $!";

print Dumper \@real_partition_index;

$line2 = <$input>;

print $line2;

close($input)
  or warn "Error: Unable to close the input file $input_filename: $!";

exit 0;
