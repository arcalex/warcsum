#! /usr/bin/perl

# Copyright (C) 2015 Bibliotheca Alexandrina

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# warcsumsplit takes a large hash manifest file and number of partitions
# as input, and attempts to split the large hash manifest file into
# number of smaller hash manifest files equal to or less than the input
# number of parititons.
#
# warcsumsplit will never break a sequence of hash manifests with the
# same hash, which might produce uneven parition.

# Input 
#
# Large hash manifest sorted on the hash with the following format:
# <WARC filename> <member offset> <member end> <URI> <date> <hash digest>

# Output 
#
# Smaller hash manifest files sorted on the hash with the following
# format:
#
# <WARC filename> <member offset> <member end> <URI> <date> <hash digest>

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper qw(Dumper);

my $input_filename = "";
my $partition_count = 0;
my $verbose;

################################
# Parse the program's options. #
################################

GetOptions ("input=s" => \$input_filename, # input filename
    "count=i" => \$partition_count, # number of required partitions
    "verbose" => \$verbose) # verbose mode
or die("Usage: warcsumsplit.pl [-i | --input <input_file>] ",
    "[-c | --count <number_of_partitions>] [-v | --verbose]");


unless(-e $input_filename)
{
  die "Error: input file $input_filename does not exist.";
}

unless(-r $input_filename)
{
  die "Error: input file $input_filename is not readable.";
}

unless($partition_count =~ /^[+]?\d+\z/ and $partition_count != 0)
{
  die "Error: $partition_count is an invalid number of split counts.";
}

my $input_size = -s $input_filename
or die "Error: input file $input_filename is empty.";

########################################################
# Calculate the approximate indices for the partitions #
########################################################

my @partition_index;

$partition_index[0] = 0;

for my $i (1 .. $partition_count - 1)
{
  use integer;
  $partition_index[$i] = $input_size / $partition_count * $i;
}

$partition_index[$#partition_index + 1] = $input_size;

open(my $input, "<", $input_filename)
or die "Error: cannot open $input_filename for reading: $!";

my @real_partition_index;

$real_partition_index[0] = 0;

for  my $i (1 .. $partition_count - 1)
{
  if($partition_index[$i] <=
      $real_partition_index[$#real_partition_index])
  {
    next;
  }
  seek($input, $partition_index[$i], 0);

  my $line = <$input>;

  defined($line = <$input>)
    or warn "Error: Could not read line at $.: $!";

  my $hash = (split(' ', $line))[-1];

  my $hash2 = $hash;

  my $line2 = "";

  my $current_pos = tell($input);

  $real_partition_index[$#real_partition_index + 1] = $current_pos;

  while($hash eq $hash2 and defined($line2 = <$input>))
  {
    $real_partition_index[$#real_partition_index] = $current_pos;
    $current_pos = tell($input);
    $hash2 = (split(' ', $line2))[-1];
  } 

}

$real_partition_index[$#real_partition_index] = $input_size;

for my $i (1 .. $#real_partition_index)
{
  seek($input, $real_partition_index[$i - 1], 0);

  open(my $output, ">", "$input_filename.$i")
    or die "Error: cannot open $input_filename for reading: $!";

  my $read;

  while(defined($read = <$input>) and $real_partition_index[$i] >=
  tell($input))
  {
    print $output $read;
  }

  close($output)
    or warn "Error: Unable to close the input file $input_filename.$i: $!";
}

close($input)
  or warn "Error: Unable to close the input file $input_filename: $!";

exit 0;
